---
sidebar_position: 1
---

# Creating a pass network using DanfoJS

In this tutorial, we will learn how to create a pass network using DanfoJS and RabonaJS.
We will be using the [StatsBomb open dataset](https://github.com/statsbomb/open-data) for this tutorial.

## Introduction

A pass network is a graph that shows the passing relationships between players in a football match.
It is a useful tool for analyzing the passing patterns of a team and the players involved in the passing sequences.
It can also be used to identify the players who are most involved in the passing sequences.

## Prerequisites

Even though we are going to explain the code in detail,
it could be nice to have a look at the [Danfo documentation](https://danfo.jsdata.org/). It is the replacement of
pandas in JS ecosystem with a similar syntax.

## Getting started

We will be using the [StatsBomb open dataset](https://github.com/statsbomb/open-data/blob/master/data/matches/2/44.json) for this tutorial.
The dataset we are going to use contains data for all the matches played by Arsenal in the famouse 2003-2004 season.
The invincible season in which Arsenal won the Premier League without losing a single match.

First we will import the required libraries and draw an empty pitch using RabonaJS.

```jsx
import Rabona from "rabonajs";
import { useEffect, useRef, useState } from "react";

export const ShotsComponent = () => {
  const [pitch, setPitch] = useState(null);

  const pitchOptions = {
    height: 80, //in px
    width: 120, //in px
    padding: 100, // in px, distance between the pitch border lines and external border
    linecolour: "#ffffff",
    fillcolour: "#7ec850",
  };
  useEffect(() => {
    if (!pitch) {
      const pitch = Rabona.pitch("pitch", pitchOptions);
      setPitch(pitch);
    }
  }, []);
  return <div id="pitch" style={{ width: "750px", margin: "auto" }} />;
};
```

import Rabona from "rabonajs";
import { useEffect, useRef, useState } from "react";

export const Pitch = () => {
  const [pitch, setPitch] = useState(null);
  // generate random shot data
  const pitchOptions = {
    height: 80, //in px
    width: 120, //in px
    padding: 100, // in px, distance between the pitch border lines and external border
    linecolour: "#ffffff",
    fillcolour: "#7ec850",
  };
  useEffect(() => {
    if (!pitch) {
      const pitch = Rabona.pitch("pitch", pitchOptions);
      setPitch(pitch);
    }
  }, []);
  return <div id="pitch" style={{ width: "750px", margin: "auto" }} />;
};

<Pitch />

## Loading the data

Let's create a dropdown menu to select the match we want to analyze.

```jsx
export const MatchSelector = ({ onChange }) => {
  const [matches, setMatches] = useState([]);
  /*
  Here we are fetching the data from github. Any provided competitionId and seasonId will work.
  */
  const getData = async () => {
    const competitionId = 2; // premier league
    const seasonId = 44; // 2003-2004 season
    const matchesResponse = await fetch(
      "https://raw.githubusercontent.com/statsbomb/open-data/master/data/matches/" +
        competitionId +
        "/" +
        seasonId +
        ".json"
    );
    const matches = await matchesResponse.json();
    setMatches(matches);
  };

  /*
    Load the data once the component is mounted
  */
  useEffect(() => {
    getData();
  }, []);

  const onMatchChange = (e) => {
    onChange(matches.find((match) => match.match_id === e.target.value));
  };

  /*
    Render the dropdown menu
  */
  return (
    <div>
      <select onChange={onMatchChange}>
        {matches.map((match) => (
          <option key={match.match_id} value={match.match_id}>
            {match.home_team.home_team_name} {match.home_score} -{" "}
            {match.away_score} {match.away_team.away_team_name}
          </option>
        ))}
      </select>
    </div>
  );
};
```

### MatchSelector Component

using `onChange` function we can get the selected match id to retrieve the data for that match.\
That will just the log the match id for now.

export const MatchSelector = ({ onChange }) => {
  const [matches, setMatches] = useState([]);
  // fetch data from github
  const getData = async () => {
    const competitionId = 2; // premier league
    const seasonId = 44; // 2003-2004 season
    const matchesResponse = await fetch(
      "https://raw.githubusercontent.com/statsbomb/open-data/master/data/matches/" +
        competitionId +
        "/" +
        seasonId +
        ".json"
    );
    const matches = await matchesResponse.json();
    setMatches(matches);
  };
  const onMatchChange = (e) => {
    onChange(matches.find((match) => match.match_id == e));
  };
  useEffect(() => {
    getData();
  }, []);
  // render the dropdown menu
  return (
    <div>
      <select onChange={(e) => onMatchChange(e.target.value)}>
        {matches.map((match) => (
          <option key={match.match_id} value={match.match_id}>
            {match.home_team.home_team_name} {match.home_score} -{" "}
            {match.away_score} {match.away_team.away_team_name}
          </option>
        ))}
      </select>
    </div>
  );
};

<MatchSelector onChange={(e) => console.log(e.target.value)} />

## Creating the pass network

Now we will create a function to create the pass network. A Pass network is weighted graph in mathematical
terms where the nodes are the players and the edges are the passes between the players.
The weight of the edge is the number of passes between the two players.
It is calculated by counting total number of passes between players in addition to
average position of the players up until the first substitution.

Let's start with importing the required methods from Danfo.

:::tip

Don't forget to install danfojs using `npm install danfojs` or `yarn add danfojs`

:::

```jsx
import { DataFrame, merge, toJSON } from "danfojs/dist/danfojs-browser/src";
```

Here we are only importing necessary methods to reduce bundle size on browser

import { DataFrame, merge, toJSON } from "danfojs/dist/danfojs-browser/src";

### Fetch the match data

First we are fetching the match data from github using the match id.

```js
const matchResponse = await fetch(
  "https://raw.githubusercontent.com/statsbomb/open-data/master/data/events/" +
    matchId +
    ".json"
);
const match = await matchResponse.json();
```

Then we are looping through the events and filtering out the passes and storing them in an array.
We should make sure that event is a pass and it has a recipient. This way unsuccesful passes are not included.

```js
const passes = [];
for (let i = 0; i < match.length; i++) {
  const event = match[i];
  if (event.type.name === "Substitution") {
    break;
  }
  if (match[i].type.name === "Pass" && event.pass.recipient) {
    passes.push({
      startX: event.location[0],
      startY: event.location[1],
      endX: event.pass.end_location[0],
      endY: event.pass.end_location[1],
      teamId: event.team.id,
      passer: event.player?.id,
      passerName: event.player?.name,
      recipient: event.pass.recipient?.id,
    });
  }
}
```

### Creating the pass network

Below we are creating a DataFrame from the passes array and grouping the passes by the passer and team id.
Afterwards calculating the average position of the passer and the number of passes made by the passer.

```js
const df = new DataFrame(passes);
const avereagePositions = df
  .groupby(["passer", "teamId"])
  .agg({ startX: "mean", startY: ["mean", "count"] })
  .rename({ startY_count: "pass_count" });
```

Whole function looks like this

```jsx
export const getPassNetworkData = async (matchId) => {
  const matchResponse = await fetch(
    "https://raw.githubusercontent.com/statsbomb/open-data/master/data/events/" +
      matchId +
      ".json"
  );
  const match = await matchResponse.json();
  const passes = [];
  for (let i = 0; i < match.length; i++) {
    const event = match[i];
    if (event.type.name === "Substitution") {
      break;
    }
    if (match[i].type.name === "Pass") {
      passes.push({
        startX: event.location[0],
        startY: event.location[1],
        endX: event.pass.end_location[0],
        endY: event.pass.end_location[1],
        teamId: event.team.id,
        passer: event.player?.id,
        passerName: event.player?.name,
        recipient: event.pass.recipient?.id,
      });
    }
  }
  const df = new DataFrame(passes);
  const avereagePositions = df
    .groupby(["passer", "teamId"])
    .agg({ startX: "mean", startY: ["mean", "count"] })
    .rename({ startY_count: "pass_count" });
};
```

This function returns a DataFrame with the average position of the passer and
the number of passes made by the passer. We will use this DataFrame to create the nodes of the graph.

This data would look like this

```js
{
    "passer": 12529,
    "teamId": 1,
    "startX_mean": 49.91,
    "startY_mean": 8.515,
    "pass_count": 20
}
```

At the next stage we will filter out the passes between each player.
We will do this by grouping the passes by the passer and the recipient. Passer's name
is also added to the DataFrame. We will use these information to visualize the nodes of the graph.

```js
const passBetween = df
  .groupby(["passer", "recipient", "passerName", "passerNumber"])
  .agg({ startY: ["count"] })
  .rename({ startY_count: "count" })
  .rename({ passerName: "label" });
```

This data would look like this

```js
{
    "passer": 12529,
    "recipient": 40221,
    "label": "J. Henderson",
    "passerNumber": 14,
    "count": 9
},
{
    "passer": 12529,
    "recipient": 1347,
    "label": "J. Henderson",
    "passerNumber": 14,
    "count": 17
},
```

All we need to do is merging these two datasets by using the `merge` method we imported early on.

```js
const passData = merge({
  left: passBetween,
  right: avereagePositions,
  on: ["passer"],
  how: "left",
});
```

This will give us a DataFrame with most of the information we need to create the nodes and edges of the graph.

```js
{
    "passer": 12529,
    "recipient": 40221,
    "label": "J. Henderson",
    "passerNumber": 14,
    "count": 9,
    "teamId": 1,
    "startX_mean": 49.91,
    "startY_mean": 8.515,
    "pass_count": 20
},
{
    "passer": 12529,
    "recipient": 1347,
    "label": "J. Henderson
    ...
```

`pass_count` is the total number of passes made by the passer and `count`
is the number of passes made between the passer and the recipient.
We still need to create recipient's average position and we will use it to create the edges of the graph.
A simple `map` function will do the trick after converting the DataFrame to JSON.
Mapping function will find the recipient's average position from the `avereagePositions`
and add it to the `passNetwork`. That will correspond the end locations of the passes.

```js
const passDataJson = toJSON(passData);
const averagePositionsJson = toJSON(avereagePositions);
const passNetwork = passDataJson.map((pass) => ({
  endX: averagePositionsJson.find(
    (position) => pass.recipient === position.passer
  ).startX_mean,
  endY: averagePositionsJson.find(
    (position) => pass.recipient === position.passer
  ).startY_mean,
  startX: pass.startX_mean,
  startY: pass.startY_mean,
  ...pass,
}));
```

### Home and away selector component

We will create a selector to select the home and away team. We can use a simple radio button for this.

```jsx
const HomeAwaySelector = ({ homeAway, setActiveTeamId }) => {
  return (
    <div>
      <label>
        <input
          type="radio"
          name="home-away"
          value={homeAway.home}
          checked={homeAway === "home"}
          onChange={(e) => setActiveTeamId(e.target.value)}
        />
        Home
      </label>
      <label>
        <input
          type="radio"
          name="home-away"
          value={homeAway.away}
          checked={homeAway === "away"}
          onChange={(e) => setActiveTeamId(e.target.value)}
        />
        Away
      </label>
    </div>
  );
};
```

export const HomeAwaySelector = ({ homeAway, setActiveTeamId, activeTeamId }) => {
  return (
    homeAway && 
    (<div>
      <label>
        <input
          type="radio"
          name="home-away"
          value={homeAway.home}
          checked={homeAway.home == activeTeamId}
          onChange={(e) => setActiveTeamId(e.target.value)}
        />
        Home
      </label>
      <label>
        <input
          type="radio"
          name="home-away"
          value={homeAway.away}
          checked={homeAway.away == activeTeamId}
          onChange={(e) => setActiveTeamId(e.target.value)}
        />
        Away
      </label>
    </div>)
  );
};

export const getPassNetworkData = async (matchId) => {
  const matchResponse = await fetch(
    "https://raw.githubusercontent.com/statsbomb/open-data/master/data/events/" +
      matchId +
      ".json"
  );
  const match = await matchResponse.json();
  console.log("match", match);
  const passes = [];
  for (let i = 0; i < match.length; i++) {
    const event = match[i];
    if (event.type.name === "Substitution") {
      break;
    }
    if (match[i].type.name === "Pass" && event.pass.recipient) {
      passes.push({
        startX: event.location[0],
        startY: event.location[1],
        endX: event.pass.end_location[0],
        endY: event.pass.end_location[1],
        teamId: event.team.id,
        passer: event.player?.id,
        passerName: event.player?.name,
        recipient: event.pass.recipient?.id,
      });
    }
  }
  const df = new DataFrame(passes);
  const avereagePositions = df
    .groupby(["passer", "teamId"])
    .agg({ startX: "mean", startY: ["mean", "count"] })
    .rename({ startX_mean: "startX", startY_mean: "startY" })
    .rename({ startY_count: "pass_count" });
  const passBetween = df
    .groupby(["passer", "recipient", "passerName"])
    .agg({ startY: ["count"] })
    .rename({ startY_count: "count" })
    .rename({ passerName: "label" });
  const passData = merge({
    left: passBetween,
    right: avereagePositions,
    on: ["passer"],
    how: "left",
  });
  let passDataJson = toJSON(passData);
  let averagePositionsJson = toJSON(avereagePositions);
  const passNetwork = passDataJson.map((pass) => ({
    endX: averagePositionsJson.find(
      (position) => pass.recipient === position.passer
    ).startX,
    endY: averagePositionsJson.find(
      (position) => pass.recipient === position.passer
    ).startY,
    startX: pass.startX,
    startY: pass.startY,
    ...pass,
  }));
  return passNetwork;
};

export const PassNetwork = () => {
  const [pitch, setPitch] = useState(null);
  const [homeAway, setHomeAway] = useState(null);
  const [activeTeamId, setActiveTeamId] = useState(null);
  // generate random shot data
  const pitchOptions = {
    height: 80, //in px
    width: 120, //in px
    padding: 100, // in px, distance between the pitch border lines and external border
    linecolour: "#ffffff",
    fillcolour: "#7ec850",
  };
  useEffect(() => {
    if (!pitch) {
      const pitch = Rabona.pitch("pitch2", pitchOptions);
      setPitch(pitch);
    }
  }, []);
  const onMatchChange = async (match) => {
    console.log({
      home: match.home_team.home_team_id,
      away: match.away_team.away_team_id,
    })
    setHomeAway({
      home: match.home_team.home_team_id,
      away: match.away_team.away_team_id,
    });
    setActiveTeamId(match.home_team.home_team_id);
    const passNetwork = await getPassNetworkData(match.match_id);
    passNetwork
      .filter((pass) => pass.teamId == match.home_team.home_team_id)
      .forEach((pass) => {
        const layer = Rabona.layer({
          type: "ballMovement",
          data: [pass],
          options: {
            color: "yellow",
          },
        }).addTo(pitch);
      });
  };
  const onActiveTeamChange = (teamId) => {
    console.log("teamId", teamId);
    setActiveTeamId(teamId);
  };
  return (
    <>
      <MatchSelector onChange={onMatchChange} />
      <HomeAwaySelector homeAway={homeAway} setActiveTeamId={onActiveTeamChange} value={activeTeamId}/>
      <div id="pitch2" style={{ width: "750px", margin: "auto" }} />
    </>
  );
};

<PassNetwork />
